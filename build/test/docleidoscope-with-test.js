// Generated by CoffeeScript 1.9.2

/*! Docleidoscope 0.0.4 //// MIT Licence //// https://github.com/richplastow/docleidoscope#readme */

(function() {
  var BaseRuntime, Client, Main, Server, Tudor, tudor, ª, ªA, ªB, ªC, ªE, ªF, ªN, ªO, ªR, ªS, ªU, ªV, ªX, ªex, ªhas, ªredefine, ªtype, ªuid,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ªC = 'Docleidoscope';

  ªV = '0.0.4';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = 'null';

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
  };

  ªuid = function(p) {
    return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
  };

  ªredefine = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };

  BaseRuntime = (function() {
    BaseRuntime.prototype.C = 'BaseRuntime';

    BaseRuntime.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function BaseRuntime(config) {
      if (ªO !== ªtype(config)) {
        throw new Error(this.C + ": `config` must be type 'object'");
      }
      this.xx = 'xx';
    }

    BaseRuntime.prototype.init = function(xx) {};

    return BaseRuntime;

  })();

  Client = (function(superClass) {
    extend(Client, superClass);

    Client.prototype.C = 'Client';

    function Client(config) {
      Client.__super__.constructor.call(this, config);
      this.env = config.env;
      if (ªS !== ªtype(this.env)) {
        throw new Error(this.C + ": `config.env` must be type 'string'");
      }
      if (!/^client$/.test(this.env)) {
        throw new Error(this.C + ": `config.env` must be 'client'");
      }
      this.wsc = null;
      this.xx = 'xx';
    }

    Client.prototype.start = function() {
      this.wsc = new WebSocket('ws://127.0.0.1:8080');
      this.wsc.onopen = (function(_this) {
        return function(evt) {
          ª('CONNECTED');
          return _this.wsc.send('123 Testing');
        };
      })(this);
      this.wsc.onclose = function(evt) {
        return ª('DISCONNECTED');
      };
      this.wsc.onmessage = function(evt) {
        return ª('RECEIVED: ' + evt.data);
      };
      return this.wsc.onerror = function(evt) {
        return ª('ERROR: ', evt);
      };
    };

    Client.prototype.stop = function() {
      this.wsc.close();
      return this.wsc = null;
    };

    Client.prototype.init = function(xx) {};

    return Client;

  })(BaseRuntime);

  Main = (function() {
    Main.prototype.C = ªC;

    Main.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Main(config) {
      if (ªO !== ªtype(config)) {
        throw new Error(this.C + ": `config` must be type 'object'");
      }
      this.env = config.env;
      if (ªS !== ªtype(this.env)) {
        throw new Error(this.C + ": `config.env` must be type 'string'");
      }
      if (!/^client|server$/.test(this.env)) {
        throw new Error(this.C + ": `config.env` must be 'client' or 'server'");
      }
      this.runtime = new ('client' === this.env ? Client : Server)(config);
    }

    Main.prototype.start = function() {
      return this.runtime.start();
    };

    Main.prototype.stop = function() {
      return this.runtime.stop();
    };

    Main.prototype.init = function(xx) {};

    return Main;

  })();

  Server = (function(superClass) {
    extend(Server, superClass);

    Server.prototype.C = 'Server';

    function Server(config) {
      this.checkDir = bind(this.checkDir, this);
      var dirRx, ref;
      Server.__super__.constructor.call(this, config);
      this.env = config.env;
      if (ªS !== ªtype(this.env)) {
        throw new Error(this.C + ": `config.env` must be type 'string'");
      }
      if (!/^server$/.test(this.env)) {
        throw new Error(this.C + ": `config.env` must be 'server'");
      }
      this.wss = config.wss;
      if (ªF !== ªtype(this.wss)) {
        throw new Error(this.C + ": `config.wss` must be type 'function'");
      }
      this.wsServer = null;
      this.fs = config.fs;
      if (ªO !== ªtype(this.fs)) {
        throw new Error(this.C + ": `config.fs` must be type 'object'");
      }
      this.dir = config.dir;
      if (ªS !== ªtype(this.dir)) {
        throw new Error(this.C + ": `config.dir` must be type 'string'");
      }
      dirRx = /^[-\/_.A-Za-z0-9]{1,128}$/;
      if (!dirRx.test(this.dir)) {
        throw new Error(this.C + ": `config.dir` fails " + dirRx);
      }
      if (!this.fs.existsSync(this.dir)) {
        throw new Error(this.C + ": `config.dir` does not exist");
      }
      this.wait = config.wait;
      if (ªN !== ªtype(this.wait)) {
        throw new Error(this.C + ": `config.wait` must be type 'number'");
      }
      if (!((100 <= (ref = this.wait) && ref <= 1000 * 60 * 60))) {
        throw new Error(this.C + ": `config.wait` must be 100-" + (1000 * 60 * 60));
      }
      this.stats = this.fs.statSync(this.dir);
      if (!this.stats.isDirectory()) {
        throw new Error(this.C + ": `config.dir` is not a directory");
      }
      this.watcher = null;
      this.files = this.fs.readdirSync(this.dir);
      this.xx = 'x';
    }

    Server.prototype.qq = function(xx) {};

    Server.prototype.start = function() {
      this.watcher = setInterval(this.checkDir, this.wait);
      this.wsServer = new this.wss({
        port: 8080
      });
      return this.wsServer.on('connection', function(ws) {
        ª('connected');
        ws.send('thanks for connecting');
        return ws.on('message', function(message) {
          ª('recieved', message);
          return ws.send('thanks for "' + message + '"');
        });
      });
    };

    Server.prototype.stop = function() {
      return clearInterval(this.watcher);
    };

    Server.prototype.checkDir = function() {
      var added, file, fileNow, filesNow, j, k, len, len1, ref, removed;
      filesNow = this.fs.readdirSync(this.dir);
      removed = false;
      ref = this.files;
      for (j = 0, len = ref.length; j < len; j++) {
        file = ref[j];
        if (-1 === filesNow.indexOf(file)) {
          removed = true;
          break;
        }
      }
      added = false;
      for (k = 0, len1 = filesNow.length; k < len1; k++) {
        fileNow = filesNow[k];
        if (-1 === this.files.indexOf(fileNow)) {
          added = true;
          break;
        }
      }
      if (removed || added) {
        ª("Files have changed");
        return this.files = filesNow;
      }
    };

    Server.prototype.onDirChange = function(evt, filename) {
      return ª(evt, filename);
    };

    return Server;

  })(BaseRuntime);

  if (ªF === typeof define && define.amd) {
    define(function() {
      return Main;
    });
  } else if (ªO === typeof module && module && module.exports) {
    module.exports = Main;
  } else {
    this[ªC] = Main;
  }

  Tudor = (function() {
    Tudor.prototype.I = 'Tudor';

    Tudor.prototype.toString = function() {
      return "[object " + I + "]";
    };

    Tudor.prototype.articles = [];

    function Tudor(opt) {
      this.opt = opt != null ? opt : {};
      this["do"] = bind(this["do"], this);
      switch (this.opt.format) {
        case 'html':
          this.pageHead = function(summary) {
            return "<style>\n  body     { font-family: sans-serif; }\n  a        { outline: 0; }\n  b        { display: inline-block; width: .7em }\n\n  b.pass              { color: #393 }\n  b.fail              { color: #bbb }\n  article.fail b.pass { color: #bbb }\n  section.fail b.pass { color: #bbb }\n\n  pre      { padding: .5em; margin: .2em 0; border-radius: 4px; }\n  pre.fn   { background-color: #fde }\n  pre.pass { background-color: #cfc }\n  pre.fail { background-color: #d8e0e8 }\n\n  article  { margin-bottom: .5rem }\n  article h2 { padding-left:.5rem; margin:0; font-weight:normal }\n  article.pass { border-left: 5px solid #9c9 }\n  article.fail { border-left: 5px solid #9bf }\n  article.fail h2 { margin-bottom: .5rem }\n  article.pass >div { display: none }\n\n  section  { margin-bottom: .5rem }\n  section h3   { padding-left: .5rem; margin: 0; }\n  section.pass { border-left: 3px solid #9c9 }\n  section.fail { border-left: 3px solid #9bf }\n  section.fail h3 { margin-bottom: .5rem }\n  section.pass >div { display: none }\n\n  article.fail section.pass { border-left-color: #ccc }\n\n  div      { padding-left: .5em; }\n  div.fail { border-left: 3px solid #9bf; font-size: .8rem }\n  div h4   { margin: 0 }\n  div h4 { font: normal .8rem/1.2rem monaco, monospace }\n  div.fail, div.fail h4 { margin: .5rem 0 }\n\n</style>\n<h4><a href=\"#end\" id=\"top\">\u2b07</a>  " + summary + "</h4>";
          };
          this.pageFoot = function(summary) {
            return "<h4><a href=\"#top\" id=\"end\">\u2b06</a>  " + summary + "</h4>\n<script>\n  document.title='" + (summary.replace(/<\/?[^>]+>/g, '')) + "';\n</script>";
          };
          this.articleHead = function(heading, fail) {
            return ("<article class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h2>" + (fail ? this.cross : this.tick) + heading + "</h2><div>");
          };
          this.articleFoot = '</div></article>';
          this.sectionHead = function(heading, fail) {
            return ("<section class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h3>" + (fail ? this.cross : this.tick) + heading + "</h3><div>");
          };
          this.sectionFoot = '</div></section>';
          this.jobFormat = function(heading, result) {
            return ("<div class=\"" + (result ? 'fail' : 'pass') + "\">") + ("<h4>" + (result ? this.cross : this.tick) + heading + "</h4>") + ("" + (result ? this.formatError(result) : '')) + "</div>";
          };
          this.tick = '<b class="pass">\u2713</b> ';
          this.cross = '<b class="fail">\u2718</b> ';
          break;
        default:
          this.pageHead = function(summary) {
            return "" + summary;
          };
          this.pageFoot = function(summary) {
            return "\n" + summary;
          };
          this.articleHead = function(heading, fail) {
            return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n===" + (new Array(heading.length).join('=')) + "\n";
          };
          this.articleFoot = '';
          this.sectionHead = function(heading, fail) {
            return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n---" + (new Array(heading.length).join('-')) + "\n";
          };
          this.sectionFoot = '';
          this.jobFormat = function(heading, result) {
            return ((result ? this.cross : this.tick) + " " + heading) + ("" + (result ? '\n' + this.formatError(result) : ''));
          };
          this.jobFoot = '';
          this.tick = '\u2713';
          this.cross = '\u2718';
      }
    }

    Tudor.prototype.add = function(lines) {
      var article, i, line, runner, section;
      article = {
        sections: []
      };
      runner = null;
      section = null;
      if (ªA !== ªtype(lines)) {
        throw new Error("`lines` isn’t an array");
      }
      if (0 === lines.length) {
        throw new Error("`lines` has no elements");
      }
      if (ªS !== ªtype(lines[0])) {
        throw new Error("`lines[0]` isn’t a string");
      }
      article.heading = lines.shift();
      i = 0;
      while (i < lines.length) {
        line = lines[i];
        switch (ªtype(line)) {
          case ªO:
            if (!line.runner) {
              throw new Error("Errant object");
            }
            runner = line.runner;
            break;
          case ªF:
            section.jobs.push(line);
            break;
          case ªS:
            if (this.isAssertion(lines[i + 1], lines[i + 2])) {
              if (!section) {
                throw new Error("Cannot add an assertion here");
              }
              section.jobs.push([runner, line, lines[++i], lines[++i]]);
            } else {
              section = {
                heading: line,
                jobs: []
              };
              article.sections.push(section);
            }
        }
        i++;
      }
      return this.articles.push(article);
    };

    Tudor.prototype["do"] = function() {
      var actual, art, artFail, artPass, article, e, error, expect, heading, j, job, k, l, len, len1, len2, mock, pge, pgeFail, pgePass, ref, ref1, ref2, result, runner, sec, secFail, secPass, section, summary;
      pge = [];
      mock = null;
      pgePass = pgeFail = 0;
      ref = this.articles;
      for (j = 0, len = ref.length; j < len; j++) {
        article = ref[j];
        art = [];
        artPass = artFail = 0;
        ref1 = article.sections;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          section = ref1[k];
          sec = [];
          secPass = secFail = 0;
          ref2 = section.jobs;
          for (l = 0, len2 = ref2.length; l < len2; l++) {
            job = ref2[l];
            switch (ªtype(job)) {
              case ªF:
                try {
                  mock = job.apply(this, mock);
                } catch (_error) {
                  e = _error;
                  error = e.message;
                }
                if (error) {
                  sec.push(this.formatMockModifierError(job, error));
                }
                break;
              case ªA:
                runner = job[0], heading = job[1], expect = job[2], actual = job[3];
                result = runner(expect, actual, mock);
                if (!result) {
                  sec.push(this.jobFormat("" + (this.sanitize(heading))));
                  pgePass++;
                  artPass++;
                  secPass++;
                } else {
                  sec.push(this.jobFormat("" + (this.sanitize(heading)), result));
                  pgeFail++;
                  artFail++;
                  secFail++;
                }
            }
          }
          sec.unshift(this.sectionHead("" + (this.sanitize(section.heading)), secFail));
          sec.push(this.sectionFoot);
          art = art.concat(sec);
        }
        art.unshift(this.articleHead("" + (this.sanitize(article.heading)), artFail));
        art.push(this.articleFoot);
        pge = pge.concat(art);
        summary = pgeFail ? this.cross + " FAILED " + pgeFail + "/" + (pgePass + pgeFail) : this.tick + " Passed " + pgePass + "/" + (pgePass + pgeFail);
      }
      pge.unshift(this.pageHead(summary));
      pge.push(this.pageFoot(summary));
      return pge.join('\n');
    };

    Tudor.prototype.formatError = function(result) {
      switch (result.length + "-" + this.opt.format) {
        case '2-html':
          return result[0] + "\n<pre class=\"fail\">" + (this.sanitize(result[1].message)) + "</pre>";
        case '2-plain':
          return result[0] + "\n" + (this.sanitize(result[1].message));
        case '3-html':
          return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + "</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + "</pre>";
        case '3-plain':
          return (this.sanitize(this.reveal(result[0]))) + "\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2])));
        case '4-html':
          return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")</pre>";
        case '4-plain':
          return (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")";
        default:
          throw new Error("Cannot process '" + result.length + "-" + this.opt.format + "'");
      }
    };

    Tudor.prototype.formatMockModifierError = function(fn, error) {
      switch (this.opt.format) {
        case 'html':
          return "<pre class=\"fn\">" + (this.sanitize(fn + '')) + "</pre>\n...encountered an exception:\n<pre class=\"fail\">" + (this.sanitize(error)) + "</pre>";
        default:
          return (this.sanitize(fn + '')) + "\n...encountered an exception:\n" + (this.sanitize(error));
      }
    };

    Tudor.prototype.reveal = function(value) {
      return value != null ? value.toString().replace(/^\s+|\s+$/g, function(match) {
        return '\u00b7' + (new Array(match.length)).join('\u00b7');
      }) : void 0;
    };

    Tudor.prototype.sanitize = function(value) {
      switch (this.opt.format) {
        case 'html':
          return value != null ? value.toString().replace(/</g, '&lt;') : void 0;
        default:
          return value;
      }
    };

    Tudor.prototype["throw"] = {
      runner: function(expect, actual, mock) {
        var e, error;
        error = false;
        try {
          actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (!error) {
          return [
            'No exception thrown, expected', {
              message: expect
            }
          ];
        } else if (expect !== error.message) {
          return [error.message, 'was thrown, but expected', expect];
        }
      }
    };

    Tudor.prototype.equal = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (expect !== result) {
          if (result + '' === expect + '') {
            return [result, 'was returned, but expected', expect, true];
          } else {
            return [result, 'was returned, but expected', expect];
          }
        }
      }
    };

    Tudor.prototype.is = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (expect !== ªtype(result)) {
          return ["type " + (ªtype(result)), 'was returned, but expected', "type " + expect];
        }
      }
    };

    Tudor.prototype.match = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (ªF !== typeof expect.test) {
          return [
            '`test()` is not a function', {
              message: expect
            }
          ];
        } else if (!expect.test('' + result)) {
          return ['' + result, 'failed test', expect];
        }
      }
    };

    Tudor.prototype.isAssertion = function(line1, line2) {
      if (ªF !== ªtype(line2)) {
        return false;
      }
      if ((ªO === ªtype(line1)) && ªF === ªtype(line1.runner)) {
        return false;
      }
      return true;
    };

    return Tudor;

  })();

  tudor = new Tudor({
    format: ªO === typeof window ? 'html' : 'plain'
  });

  Main.runTest = tudor["do"];

  tudor.add([
    "01 Docleidoscope Constructor Usage", tudor.is, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Main;
    }, "The instance is an object", ªO, function() {
      return new Main({
        env: 'client'
      });
    }
  ]);

  tudor.add([
    "02 Docleidoscope Constructor Errors", tudor["throw"], "`config` errors", "`config` missing", "Docleidoscope: `config` must be type 'object'", function() {
      return new Main;
    }, "`config` wrong type", "Docleidoscope: `config` must be type 'object'", function() {
      return new Main([]);
    }, "`config.env` errors", "`config.env` missing", "Docleidoscope: `config.env` must be type 'string'", function() {
      return new Main({});
    }, "`config.env` wrong type", "Docleidoscope: `config.env` must be type 'string'", function() {
      return new Main({
        env: 123
      });
    }, "`config.env` string not recognized", "Docleidoscope: `config.env` must be 'client' or 'server'", function() {
      return new Main({
        env: 'wrong'
      });
    }
  ]);

  tudor.add([
    "03 Client Constructor Usage", tudor.is, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Client;
    }, "The instance is an object", ªO, function() {
      return new Client({
        env: 'client'
      });
    }
  ]);

  tudor.add([
    "04 Client Constructor Errors", tudor["throw"], "`config` errors", "`config` missing", "Client: `config` must be type 'object'", function() {
      return new Client;
    }, "`config` wrong type", "Client: `config` must be type 'object'", function() {
      return new Client([]);
    }, "`config.env` errors", "`config.env` missing", "Client: `config.env` must be type 'string'", function() {
      return new Client({});
    }, "`config.env` wrong type", "Client: `config.env` must be type 'string'", function() {
      return new Client({
        env: 123
      });
    }, "`config.env` string is 'server'", "Client: `config.env` must be 'client'", function() {
      return new Client({
        env: 'server'
      });
    }
  ]);

  tudor.add([
    "05 Server Constructor Usage", tudor.is, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Server;
    }, "The instance is an object", ªO, function() {
      var server;
      return server = new Server({
        env: 'server',
        dir: 'path/to/watch',
        wait: 1000,
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return true;
          },
          readdirSync: function() {
            return [];
          },
          statSync: function() {
            return {
              isDirectory: function() {
                return true;
              }
            };
          }
        }
      });
    }, "Changes made to watched directory", tudor.equal, "New file added after 300ms", '@todo async Tudor feature', function() {
      var server;
      server = new Server({
        env: 'server',
        dir: 'path/to/watch',
        wait: 100,
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return true;
          },
          readdirSync: function() {},
          statSync: function() {
            return {
              isDirectory: function() {
                return true;
              }
            };
          }
        }
      });
      return '@todo async Tudor feature';
    }
  ]);

  tudor.add([
    "06 Server Constructor Errors", tudor["throw"], "`config` errors", "`config` missing", "Server: `config` must be type 'object'", function() {
      return new Server;
    }, "`config` wrong type", "Server: `config` must be type 'object'", function() {
      return new Server([]);
    }, "`config.env` errors", "`config.env` missing", "Server: `config.env` must be type 'string'", function() {
      return new Server({});
    }, "`config.env` wrong type", "Server: `config.env` must be type 'string'", function() {
      return new Server({
        env: 123
      });
    }, "`config.env` string is 'client'", "Server: `config.env` must be 'server'", function() {
      return new Server({
        env: 'client'
      });
    }, "`config.dir` errors", "`config.dir` missing", "Server: `config.dir` must be type 'string'", function() {
      return new Server({
        env: 'server',
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {}
      });
    }, "`config.dir` wrong type", "Server: `config.dir` must be type 'string'", function() {
      return new Server({
        env: 'server',
        dir: true,
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {}
      });
    }, "`config.dir` is an empty string", "Server: `config.dir` fails /^[-\\\/_.A-Za-z0-9]{1,128}$/", function() {
      return new Server({
        env: 'server',
        dir: '',
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {}
      });
    }, "`config.dir` string contains unexpected characters", "Server: `config.dir` fails /^[-\\\/_.A-Za-z0-9]{1,128}$/", function() {
      return new Server({
        env: 'server',
        dir: 'nöpe',
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {}
      });
    }, "`config.dir` points to non-existant dir", "Server: `config.dir` does not exist", function() {
      return new Server({
        env: 'server',
        dir: 'does/not/exist',
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return false;
          }
        }
      });
    }, "`config.dir` points to a file, not a dir", "Server: `config.dir` is not a directory", function() {
      return new Server({
        env: 'server',
        dir: 'is/not/a/dir',
        wait: 1000,
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return true;
          },
          statSync: function() {
            return {
              isDirectory: function() {
                return false;
              }
            };
          }
        }
      });
    }, "`config.fs` errors", "`config.fs` missing", "Server: `config.fs` must be type 'object'", function() {
      return new Server({
        env: 'server',
        dir: 'path/to/files',
        wss: function() {
          return {
            on: function() {}
          };
        }
      });
    }, "`config.fs` wrong type", "Server: `config.fs` must be type 'object'", function() {
      return new Server({
        env: 'server',
        dir: 'path/to/files',
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: []
      });
    }, "`config.wss` errors", "`config.wss` missing", "Server: `config.wss` must be type 'function'", function() {
      return new Server({
        env: 'server',
        dir: 'path/to/files'
      });
    }, "`config.wss` wrong type", "Server: `config.wss` must be type 'function'", function() {
      return new Server({
        env: 'server',
        dir: 'path/to/files',
        wss: {
          on: function() {}
        }
      });
    }, "`config.wait` errors", "`config.wait` missing", "Server: `config.wait` must be type 'number'", function() {
      return new Server({
        env: 'server',
        dir: 'is/a/dir',
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return true;
          },
          statSync: function() {
            return {
              isDirectory: function() {
                return true;
              }
            };
          }
        }
      });
    }, "`config.wait` wrong type", "Server: `config.wait` must be type 'number'", function() {
      return new Server({
        env: 'server',
        dir: 'is/a/dir',
        wait: '1000',
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return true;
          },
          statSync: function() {
            return {
              isDirectory: function() {
                return true;
              }
            };
          }
        }
      });
    }, "`config.wait` too small", "Server: `config.wait` must be 100-3600000", function() {
      return new Server({
        env: 'server',
        dir: 'is/a/dir',
        wait: 99.99,
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return true;
          },
          statSync: function() {
            return {
              isDirectory: function() {
                return true;
              }
            };
          }
        }
      });
    }, "`config.wait` too big", "Server: `config.wait` must be 100-3600000", function() {
      return new Server({
        env: 'server',
        dir: 'is/a/dir',
        wait: 1000 * 60 * 60 + 0.1,
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return true;
          },
          statSync: function() {
            return {
              isDirectory: function() {
                return true;
              }
            };
          }
        }
      });
    }
  ]);

}).call(this);
