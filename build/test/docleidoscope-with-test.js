// Generated by CoffeeScript 1.9.2

/*! Docleidoscope 0.0.5 //// MIT Licence //// https://github.com/richplastow/docleidoscope#readme */

(function() {
  var $, $$, BaseRuntime, ClientRuntime, Main, ServerRuntime, Tudor, WsClient, document, tudor, ª, ªA, ªB, ªC, ªE, ªF, ªN, ªO, ªR, ªS, ªU, ªV, ªX, ªex, ªhas, ªredefine, ªtype, ªuid,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ªC = 'Docleidoscope';

  ªV = '0.0.5';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = 'null';

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
  };

  ªuid = function(p) {
    return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
  };

  ªredefine = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };

  BaseRuntime = (function() {
    BaseRuntime.prototype.C = 'BaseRuntime';

    BaseRuntime.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function BaseRuntime(config) {
      if (ªO !== ªtype(config)) {
        throw new Error(this.C + ": `config` must be type 'object'");
      }
      this.xx = 'xx';
    }

    BaseRuntime.prototype.init = function(xx) {};

    return BaseRuntime;

  })();

  ClientRuntime = (function(superClass) {
    extend(ClientRuntime, superClass);

    ClientRuntime.prototype.C = 'ClientRuntime';

    function ClientRuntime(config) {
      ClientRuntime.__super__.constructor.call(this, config);
      this.env = config.env;
      if (ªS !== ªtype(this.env)) {
        throw new Error(this.C + ": `config.env` must be type 'string'");
      }
      if (!/^client$/.test(this.env)) {
        throw new Error(this.C + ": `config.env` must be 'client'");
      }
      this.wsc = null;
      this.ID = null;
      this.files = [];
      this.listeners = {};
      this.xx = 'xx';
    }

    ClientRuntime.prototype.start = function() {
      this.wsc = new WebSocket('ws://127.0.0.1:8080');
      this.wsc.onopen = function(evt) {
        return ª('CONNECTED');
      };
      this.wsc.onclose = function(evt) {
        this.ID = null;
        return ª('DISCONNECTED');
      };
      this.wsc.onerror = function(evt) {
        return ª('ERROR: ', evt);
      };
      return this.wsc.onmessage = (function(_this) {
        return function(evt) {
          var j, len, ref, updateListener;
          if ('You are: ' === evt.data.slice(0, 9)) {
            _this.ID = evt.data.slice(9);
            ª('ASSIGNED ID: ' + _this.ID);
            return _this.wsc.send('I am ' + _this.ID);
          } else if ('Update files: ' === evt.data.slice(0, 14)) {
            _this.files = JSON.parse(evt.data.slice(14));
            if (_this.listeners.update) {
              ref = _this.listeners.update;
              for (j = 0, len = ref.length; j < len; j++) {
                updateListener = ref[j];
                updateListener();
              }
            }
            return ª('UPDATE FILES: ', _this.files);
          } else {
            return ª('UNEXPECTED MESSAGE: ' + evt.data);
          }
        };
      })(this);
    };

    ClientRuntime.prototype.stop = function() {
      this.wsc.close();
      return this.wsc = null;
    };

    ClientRuntime.prototype.on = function(evt, cb) {
      if (!this.listeners[evt]) {
        this.listeners[evt] = [];
      }
      return this.listeners[evt].push(cb);
    };

    ClientRuntime.prototype.xx = function(xx) {};

    return ClientRuntime;

  })(BaseRuntime);

  Main = (function() {
    Main.prototype.C = ªC;

    Main.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Main(config) {
      if (ªO !== ªtype(config)) {
        throw new Error(this.C + ": `config` must be type 'object'");
      }
      this.env = config.env;
      if (ªS !== ªtype(this.env)) {
        throw new Error(this.C + ": `config.env` must be type 'string'");
      }
      if (!/^client|server$/.test(this.env)) {
        throw new Error(this.C + ": `config.env` must be 'client' or 'server'");
      }
      if ('client' === this.env) {
        this.runtime = new ClientRuntime(config);
      } else {
        this.runtime = new ServerRuntime(config);
      }
    }

    Main.prototype.start = function() {
      return this.runtime.start();
    };

    Main.prototype.stop = function() {
      return this.runtime.stop();
    };

    Main.prototype.init = function(xx) {};

    return Main;

  })();

  ServerRuntime = (function(superClass) {
    extend(ServerRuntime, superClass);

    ServerRuntime.prototype.C = 'ServerRuntime';

    function ServerRuntime(config) {
      this.checkDir = bind(this.checkDir, this);
      var dirRx, ref;
      ServerRuntime.__super__.constructor.call(this, config);
      this.env = config.env;
      if (ªS !== ªtype(this.env)) {
        throw new Error(this.C + ": `config.env` must be type 'string'");
      }
      if (!/^server$/.test(this.env)) {
        throw new Error(this.C + ": `config.env` must be 'server'");
      }
      this.wss = config.wss;
      if (ªF !== ªtype(this.wss)) {
        throw new Error(this.C + ": `config.wss` must be type 'function'");
      }
      this.wsServer = null;
      this.fs = config.fs;
      if (ªO !== ªtype(this.fs)) {
        throw new Error(this.C + ": `config.fs` must be type 'object'");
      }
      this.dir = config.dir;
      if (ªS !== ªtype(this.dir)) {
        throw new Error(this.C + ": `config.dir` must be type 'string'");
      }
      dirRx = /^[-\/_.A-Za-z0-9]{1,128}$/;
      if (!dirRx.test(this.dir)) {
        throw new Error(this.C + ": `config.dir` fails " + dirRx);
      }
      if (!this.fs.existsSync(this.dir)) {
        throw new Error(this.C + ": `config.dir` does not exist");
      }
      this.wait = config.wait;
      if (ªN !== ªtype(this.wait)) {
        throw new Error(this.C + ": `config.wait` must be type 'number'");
      }
      if (!((100 <= (ref = this.wait) && ref <= 1000 * 60 * 60))) {
        throw new Error(this.C + ": `config.wait` must be 100-" + (1000 * 60 * 60));
      }
      this.stats = this.fs.statSync(this.dir);
      if (!this.stats.isDirectory()) {
        throw new Error(this.C + ": `config.dir` is not a directory");
      }
      this.watcher = null;
      this.files = this.fs.readdirSync(this.dir);
      this.wsClients = [];
      this.xx = 'x';
    }

    ServerRuntime.prototype.qq = function(xx) {};

    ServerRuntime.prototype.start = function() {
      this.watcher = setInterval(this.checkDir, this.wait);
      this.wsServer = new this.wss({
        port: 8080
      });
      return this.wsServer.on('connection', (function(_this) {
        return function(ws) {
          var ID, wsClient;
          wsClient = new WsClient;
          ID = wsClient.ID;
          wsClient.ws = ws;
          _this.wsClients.push(wsClient);
          ª('Connected to ' + ID + ' (' + _this.wsClients.length + ' in total)');
          ws.send('You are: ' + ID);
          wsClient.filesUpdate(_this.files);
          return ws.on('message', function(message) {
            ª('Received from ' + ID + ':\n  ' + message);
            return ws.send('thanks for "' + message + '"');
          });
        };
      })(this));
    };

    ServerRuntime.prototype.stop = function() {
      return clearInterval(this.watcher);
    };

    ServerRuntime.prototype.checkDir = function() {
      var added, file, fileNow, filesNow, j, k, l, len, len1, len2, ref, ref1, removed, results, wsClient;
      filesNow = this.fs.readdirSync(this.dir);
      removed = false;
      ref = this.files;
      for (j = 0, len = ref.length; j < len; j++) {
        file = ref[j];
        if (-1 === filesNow.indexOf(file)) {
          removed = true;
          break;
        }
      }
      added = false;
      for (k = 0, len1 = filesNow.length; k < len1; k++) {
        fileNow = filesNow[k];
        if (-1 === this.files.indexOf(fileNow)) {
          added = true;
          break;
        }
      }
      if (removed || added) {
        this.files = filesNow;
        ref1 = this.wsClients;
        results = [];
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          wsClient = ref1[l];
          results.push(wsClient.filesUpdate(this.files));
        }
        return results;
      }
    };

    ServerRuntime.prototype.onDirChange = function(evt, filename) {
      return ª(evt, filename);
    };

    return ServerRuntime;

  })(BaseRuntime);

  WsClient = (function() {
    WsClient.prototype.C = 'WsClient';

    function WsClient(config) {
      this.ID = ªuid(this.C);
      this.allowed = {
        mp4: true
      };
    }

    WsClient.prototype.filesUpdate = function(files) {
      var ext, file, j, len, ok;
      ok = [];
      for (j = 0, len = files.length; j < len; j++) {
        file = files[j];
        ext = file.split('.').pop().toLowerCase();
        if (ext && this.allowed[ext]) {
          ok.push(file);
        }
      }
      return this.ws.send('Update files: ' + JSON.stringify(ok));
    };

    WsClient.prototype.init = function(xx) {};

    return WsClient;

  })();

  if (!document) {
    document = {
      querySelector: {
        bind: function() {}
      },
      querySelectorAll: {
        bind: function() {}
      }
    };
  }

  $ = document.querySelector.bind(document);

  $$ = document.querySelectorAll.bind(document);

  if (ªF === typeof define && define.amd) {
    define(function() {
      return Main;
    });
  } else if (ªO === typeof module && module && module.exports) {
    module.exports = Main;
  } else {
    this[ªC] = Main;
  }

  Tudor = (function() {
    Tudor.prototype.I = 'Tudor';

    Tudor.prototype.toString = function() {
      return "[object " + I + "]";
    };

    Tudor.prototype.articles = [];

    function Tudor(opt) {
      this.opt = opt != null ? opt : {};
      this["do"] = bind(this["do"], this);
      switch (this.opt.format) {
        case 'html':
          this.pageHead = function(summary) {
            return "<style>\n  body     { font-family: sans-serif; }\n  a        { outline: 0; }\n  b        { display: inline-block; width: .7em }\n\n  b.pass              { color: #393 }\n  b.fail              { color: #bbb }\n  article.fail b.pass { color: #bbb }\n  section.fail b.pass { color: #bbb }\n\n  pre      { padding: .5em; margin: .2em 0; border-radius: 4px; }\n  pre.fn   { background-color: #fde }\n  pre.pass { background-color: #cfc }\n  pre.fail { background-color: #d8e0e8 }\n\n  article  { margin-bottom: .5rem }\n  article h2 { padding-left:.5rem; margin:0; font-weight:normal }\n  article.pass { border-left: 5px solid #9c9 }\n  article.fail { border-left: 5px solid #9bf }\n  article.fail h2 { margin-bottom: .5rem }\n  article.pass >div { display: none }\n\n  section  { margin-bottom: .5rem }\n  section h3   { padding-left: .5rem; margin: 0; }\n  section.pass { border-left: 3px solid #9c9 }\n  section.fail { border-left: 3px solid #9bf }\n  section.fail h3 { margin-bottom: .5rem }\n  section.pass >div { display: none }\n\n  article.fail section.pass { border-left-color: #ccc }\n\n  div      { padding-left: .5em; }\n  div.fail { border-left: 3px solid #9bf; font-size: .8rem }\n  div h4   { margin: 0 }\n  div h4 { font: normal .8rem/1.2rem monaco, monospace }\n  div.fail, div.fail h4 { margin: .5rem 0 }\n\n</style>\n<h4><a href=\"#end\" id=\"top\">\u2b07</a>  " + summary + "</h4>";
          };
          this.pageFoot = function(summary) {
            return "<h4><a href=\"#top\" id=\"end\">\u2b06</a>  " + summary + "</h4>\n<script>\n  document.title='" + (summary.replace(/<\/?[^>]+>/g, '')) + "';\n</script>";
          };
          this.articleHead = function(heading, fail) {
            return ("<article class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h2>" + (fail ? this.cross : this.tick) + heading + "</h2><div>");
          };
          this.articleFoot = '</div></article>';
          this.sectionHead = function(heading, fail) {
            return ("<section class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h3>" + (fail ? this.cross : this.tick) + heading + "</h3><div>");
          };
          this.sectionFoot = '</div></section>';
          this.jobFormat = function(heading, result) {
            return ("<div class=\"" + (result ? 'fail' : 'pass') + "\">") + ("<h4>" + (result ? this.cross : this.tick) + heading + "</h4>") + ("" + (result ? this.formatError(result) : '')) + "</div>";
          };
          this.tick = '<b class="pass">\u2713</b> ';
          this.cross = '<b class="fail">\u2718</b> ';
          break;
        default:
          this.pageHead = function(summary) {
            return "" + summary;
          };
          this.pageFoot = function(summary) {
            return "\n" + summary;
          };
          this.articleHead = function(heading, fail) {
            return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n===" + (new Array(heading.length).join('=')) + "\n";
          };
          this.articleFoot = '';
          this.sectionHead = function(heading, fail) {
            return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n---" + (new Array(heading.length).join('-')) + "\n";
          };
          this.sectionFoot = '';
          this.jobFormat = function(heading, result) {
            return ((result ? this.cross : this.tick) + " " + heading) + ("" + (result ? '\n' + this.formatError(result) : ''));
          };
          this.jobFoot = '';
          this.tick = '\u2713';
          this.cross = '\u2718';
      }
    }

    Tudor.prototype.add = function(lines) {
      var article, i, line, runner, section;
      article = {
        sections: []
      };
      runner = null;
      section = null;
      if (ªA !== ªtype(lines)) {
        throw new Error("`lines` isn’t an array");
      }
      if (0 === lines.length) {
        throw new Error("`lines` has no elements");
      }
      if (ªS !== ªtype(lines[0])) {
        throw new Error("`lines[0]` isn’t a string");
      }
      article.heading = lines.shift();
      i = 0;
      while (i < lines.length) {
        line = lines[i];
        switch (ªtype(line)) {
          case ªO:
            if (!line.runner) {
              throw new Error("Errant object");
            }
            runner = line.runner;
            break;
          case ªF:
            section.jobs.push(line);
            break;
          case ªS:
            if (this.isAssertion(lines[i + 1], lines[i + 2])) {
              if (!section) {
                throw new Error("Cannot add an assertion here");
              }
              section.jobs.push([runner, line, lines[++i], lines[++i]]);
            } else {
              section = {
                heading: line,
                jobs: []
              };
              article.sections.push(section);
            }
        }
        i++;
      }
      return this.articles.push(article);
    };

    Tudor.prototype["do"] = function() {
      var actual, art, artFail, artPass, article, e, error, expect, heading, j, job, k, l, len, len1, len2, mock, pge, pgeFail, pgePass, ref, ref1, ref2, result, runner, sec, secFail, secPass, section, summary;
      pge = [];
      mock = null;
      pgePass = pgeFail = 0;
      ref = this.articles;
      for (j = 0, len = ref.length; j < len; j++) {
        article = ref[j];
        art = [];
        artPass = artFail = 0;
        ref1 = article.sections;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          section = ref1[k];
          sec = [];
          secPass = secFail = 0;
          ref2 = section.jobs;
          for (l = 0, len2 = ref2.length; l < len2; l++) {
            job = ref2[l];
            switch (ªtype(job)) {
              case ªF:
                try {
                  mock = job.apply(this, mock);
                } catch (_error) {
                  e = _error;
                  error = e.message;
                }
                if (error) {
                  sec.push(this.formatMockModifierError(job, error));
                }
                break;
              case ªA:
                runner = job[0], heading = job[1], expect = job[2], actual = job[3];
                result = runner(expect, actual, mock);
                if (!result) {
                  sec.push(this.jobFormat("" + (this.sanitize(heading))));
                  pgePass++;
                  artPass++;
                  secPass++;
                } else {
                  sec.push(this.jobFormat("" + (this.sanitize(heading)), result));
                  pgeFail++;
                  artFail++;
                  secFail++;
                }
            }
          }
          sec.unshift(this.sectionHead("" + (this.sanitize(section.heading)), secFail));
          sec.push(this.sectionFoot);
          art = art.concat(sec);
        }
        art.unshift(this.articleHead("" + (this.sanitize(article.heading)), artFail));
        art.push(this.articleFoot);
        pge = pge.concat(art);
        summary = pgeFail ? this.cross + " FAILED " + pgeFail + "/" + (pgePass + pgeFail) : this.tick + " Passed " + pgePass + "/" + (pgePass + pgeFail);
      }
      pge.unshift(this.pageHead(summary));
      pge.push(this.pageFoot(summary));
      return pge.join('\n');
    };

    Tudor.prototype.formatError = function(result) {
      switch (result.length + "-" + this.opt.format) {
        case '2-html':
          return result[0] + "\n<pre class=\"fail\">" + (this.sanitize(result[1].message)) + "</pre>";
        case '2-plain':
          return result[0] + "\n" + (this.sanitize(result[1].message));
        case '3-html':
          return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + "</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + "</pre>";
        case '3-plain':
          return (this.sanitize(this.reveal(result[0]))) + "\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2])));
        case '4-html':
          return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")</pre>";
        case '4-plain':
          return (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")";
        default:
          throw new Error("Cannot process '" + result.length + "-" + this.opt.format + "'");
      }
    };

    Tudor.prototype.formatMockModifierError = function(fn, error) {
      switch (this.opt.format) {
        case 'html':
          return "<pre class=\"fn\">" + (this.sanitize(fn + '')) + "</pre>\n...encountered an exception:\n<pre class=\"fail\">" + (this.sanitize(error)) + "</pre>";
        default:
          return (this.sanitize(fn + '')) + "\n...encountered an exception:\n" + (this.sanitize(error));
      }
    };

    Tudor.prototype.reveal = function(value) {
      return value != null ? value.toString().replace(/^\s+|\s+$/g, function(match) {
        return '\u00b7' + (new Array(match.length)).join('\u00b7');
      }) : void 0;
    };

    Tudor.prototype.sanitize = function(value) {
      switch (this.opt.format) {
        case 'html':
          return value != null ? value.toString().replace(/</g, '&lt;') : void 0;
        default:
          return value;
      }
    };

    Tudor.prototype["throw"] = {
      runner: function(expect, actual, mock) {
        var e, error;
        error = false;
        try {
          actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (!error) {
          return [
            'No exception thrown, expected', {
              message: expect
            }
          ];
        } else if (expect !== error.message) {
          return [error.message, 'was thrown, but expected', expect];
        }
      }
    };

    Tudor.prototype.equal = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (expect !== result) {
          if (result + '' === expect + '') {
            return [result, 'was returned, but expected', expect, true];
          } else {
            return [result, 'was returned, but expected', expect];
          }
        }
      }
    };

    Tudor.prototype.is = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (expect !== ªtype(result)) {
          return ["type " + (ªtype(result)), 'was returned, but expected', "type " + expect];
        }
      }
    };

    Tudor.prototype.match = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (ªF !== typeof expect.test) {
          return [
            '`test()` is not a function', {
              message: expect
            }
          ];
        } else if (!expect.test('' + result)) {
          return ['' + result, 'failed test', expect];
        }
      }
    };

    Tudor.prototype.isAssertion = function(line1, line2) {
      if (ªF !== ªtype(line2)) {
        return false;
      }
      if ((ªO === ªtype(line1)) && ªF === ªtype(line1.runner)) {
        return false;
      }
      return true;
    };

    return Tudor;

  })();

  tudor = new Tudor({
    format: ªO === typeof window ? 'html' : 'plain'
  });

  Main.runTest = tudor["do"];

  tudor.add([
    "01 Docleidoscope Constructor Usage", tudor.is, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Main;
    }, "The instance is an object", ªO, function() {
      return new Main({
        env: 'client'
      });
    }
  ]);

  tudor.add([
    "02 Docleidoscope Constructor Errors", tudor["throw"], "`config` errors", "`config` missing", "Docleidoscope: `config` must be type 'object'", function() {
      return new Main;
    }, "`config` wrong type", "Docleidoscope: `config` must be type 'object'", function() {
      return new Main([]);
    }, "`config.env` errors", "`config.env` missing", "Docleidoscope: `config.env` must be type 'string'", function() {
      return new Main({});
    }, "`config.env` wrong type", "Docleidoscope: `config.env` must be type 'string'", function() {
      return new Main({
        env: 123
      });
    }, "`config.env` string not recognized", "Docleidoscope: `config.env` must be 'client' or 'server'", function() {
      return new Main({
        env: 'wrong'
      });
    }
  ]);

  tudor.add([
    "03 ClientRuntime Constructor Usage", tudor.is, "The class and instance are expected types", "The class is a function", ªF, function() {
      return ClientRuntime;
    }, "The instance is an object", ªO, function() {
      return new ClientRuntime({
        env: 'client'
      });
    }
  ]);

  tudor.add([
    "04 ClientRuntime Constructor Errors", tudor["throw"], "`config` errors", "`config` missing", "ClientRuntime: `config` must be type 'object'", function() {
      return new ClientRuntime;
    }, "`config` wrong type", "ClientRuntime: `config` must be type 'object'", function() {
      return new ClientRuntime([]);
    }, "`config.env` errors", "`config.env` missing", "ClientRuntime: `config.env` must be type 'string'", function() {
      return new ClientRuntime({});
    }, "`config.env` wrong type", "ClientRuntime: `config.env` must be type 'string'", function() {
      return new ClientRuntime({
        env: 123
      });
    }, "`config.env` string is 'server'", "ClientRuntime: `config.env` must be 'client'", function() {
      return new ClientRuntime({
        env: 'server'
      });
    }
  ]);

  tudor.add([
    "05 ServerRuntime Constructor Usage", tudor.is, "The class and instance are expected types", "The class is a function", ªF, function() {
      return ServerRuntime;
    }, "The instance is an object", ªO, function() {
      var server;
      return server = new ServerRuntime({
        env: 'server',
        dir: 'path/to/watch',
        wait: 1000,
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return true;
          },
          readdirSync: function() {
            return [];
          },
          statSync: function() {
            return {
              isDirectory: function() {
                return true;
              }
            };
          }
        }
      });
    }, "Changes made to watched directory", tudor.equal, "New file added after 300ms", '@todo async Tudor feature', function() {
      var server;
      server = new ServerRuntime({
        env: 'server',
        dir: 'path/to/watch',
        wait: 100,
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return true;
          },
          readdirSync: function() {},
          statSync: function() {
            return {
              isDirectory: function() {
                return true;
              }
            };
          }
        }
      });
      return '@todo async Tudor feature';
    }
  ]);

  tudor.add([
    "06 ServerRuntime Constructor Errors", tudor["throw"], "`config` errors", "`config` missing", "ServerRuntime: `config` must be type 'object'", function() {
      return new ServerRuntime;
    }, "`config` wrong type", "ServerRuntime: `config` must be type 'object'", function() {
      return new ServerRuntime([]);
    }, "`config.env` errors", "`config.env` missing", "ServerRuntime: `config.env` must be type 'string'", function() {
      return new ServerRuntime({});
    }, "`config.env` wrong type", "ServerRuntime: `config.env` must be type 'string'", function() {
      return new ServerRuntime({
        env: 123
      });
    }, "`config.env` string is 'client'", "ServerRuntime: `config.env` must be 'server'", function() {
      return new ServerRuntime({
        env: 'client'
      });
    }, "`config.dir` errors", "`config.dir` missing", "ServerRuntime: `config.dir` must be type 'string'", function() {
      return new ServerRuntime({
        env: 'server',
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {}
      });
    }, "`config.dir` wrong type", "ServerRuntime: `config.dir` must be type 'string'", function() {
      return new ServerRuntime({
        env: 'server',
        dir: true,
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {}
      });
    }, "`config.dir` is an empty string", "ServerRuntime: `config.dir` fails /^[-\\\/_.A-Za-z0-9]{1,128}$/", function() {
      return new ServerRuntime({
        env: 'server',
        dir: '',
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {}
      });
    }, "`config.dir` string contains unexpected characters", "ServerRuntime: `config.dir` fails /^[-\\\/_.A-Za-z0-9]{1,128}$/", function() {
      return new ServerRuntime({
        env: 'server',
        dir: 'nöpe',
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {}
      });
    }, "`config.dir` points to non-existant dir", "ServerRuntime: `config.dir` does not exist", function() {
      return new ServerRuntime({
        env: 'server',
        dir: 'does/not/exist',
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return false;
          }
        }
      });
    }, "`config.dir` points to a file, not a dir", "ServerRuntime: `config.dir` is not a directory", function() {
      return new ServerRuntime({
        env: 'server',
        dir: 'is/not/a/dir',
        wait: 1000,
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return true;
          },
          statSync: function() {
            return {
              isDirectory: function() {
                return false;
              }
            };
          }
        }
      });
    }, "`config.fs` errors", "`config.fs` missing", "ServerRuntime: `config.fs` must be type 'object'", function() {
      return new ServerRuntime({
        env: 'server',
        dir: 'path/to/files',
        wss: function() {
          return {
            on: function() {}
          };
        }
      });
    }, "`config.fs` wrong type", "ServerRuntime: `config.fs` must be type 'object'", function() {
      return new ServerRuntime({
        env: 'server',
        dir: 'path/to/files',
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: []
      });
    }, "`config.wss` errors", "`config.wss` missing", "ServerRuntime: `config.wss` must be type 'function'", function() {
      return new ServerRuntime({
        env: 'server',
        dir: 'path/to/files'
      });
    }, "`config.wss` wrong type", "ServerRuntime: `config.wss` must be type 'function'", function() {
      return new ServerRuntime({
        env: 'server',
        dir: 'path/to/files',
        wss: {
          on: function() {}
        }
      });
    }, "`config.wait` errors", "`config.wait` missing", "ServerRuntime: `config.wait` must be type 'number'", function() {
      return new ServerRuntime({
        env: 'server',
        dir: 'is/a/dir',
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return true;
          },
          statSync: function() {
            return {
              isDirectory: function() {
                return true;
              }
            };
          }
        }
      });
    }, "`config.wait` wrong type", "ServerRuntime: `config.wait` must be type 'number'", function() {
      return new ServerRuntime({
        env: 'server',
        dir: 'is/a/dir',
        wait: '1000',
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return true;
          },
          statSync: function() {
            return {
              isDirectory: function() {
                return true;
              }
            };
          }
        }
      });
    }, "`config.wait` too small", "ServerRuntime: `config.wait` must be 100-3600000", function() {
      return new ServerRuntime({
        env: 'server',
        dir: 'is/a/dir',
        wait: 99.99,
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return true;
          },
          statSync: function() {
            return {
              isDirectory: function() {
                return true;
              }
            };
          }
        }
      });
    }, "`config.wait` too big", "ServerRuntime: `config.wait` must be 100-3600000", function() {
      return new ServerRuntime({
        env: 'server',
        dir: 'is/a/dir',
        wait: 1000 * 60 * 60 + 0.1,
        wss: function() {
          return {
            on: function() {}
          };
        },
        fs: {
          existsSync: function() {
            return true;
          },
          statSync: function() {
            return {
              isDirectory: function() {
                return true;
              }
            };
          }
        }
      });
    }
  ]);

}).call(this);
